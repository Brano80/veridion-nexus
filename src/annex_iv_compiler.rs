use printpdf::*;
use serde::Serialize;
use std::fs::File;
use std::io::BufWriter;
use utoipa::ToSchema;

/// A compliance record for the Annex IV report
#[derive(Debug, Clone, Serialize, ToSchema)]
pub struct ComplianceRecord {
    /// Timestamp when the action was logged
    #[schema(example = "2024-01-15 14:30:00")]
    pub timestamp: String,
    /// Summary of the agent action
    #[schema(example = "agent-001: Credit Check")]
    pub action_summary: String,
    /// Qualified Electronic Seal ID from eIDAS provider
    #[schema(example = "SEAL-2024-01-15-ABC123")]
    pub seal_id: String,
    /// Compliance status of the action
    #[schema(example = "COMPLIANT")]
    pub status: String,
}

/// Generate an Annex IV compliance report PDF
/// 
/// # Arguments
/// 
/// * `records` - Vector of compliance records to include in the report
/// * `output_path` - Path where the PDF file should be saved
/// 
/// # Returns
/// 
/// * `Ok(())` if the PDF was generated successfully
/// * `Err(String)` if there was an error generating the PDF
pub fn generate_report(records: &Vec<ComplianceRecord>, output_path: &str) -> Result<(), String> {
    // Initialize a new PDF document
    let (doc, page1, layer1) = PdfDocument::new("Veridion Compliance Report", Mm(210.0), Mm(297.0), "Layer 1");
    
    // Get the current layer to add content
    let current_layer = doc.get_page(page1).get_layer(layer1);
    
    // Add header: "EU AI ACT - ANNEX IV TECHNICAL DOCUMENTATION"
    let font = doc.add_builtin_font(BuiltinFont::HelveticaBold)
        .map_err(|e| format!("Failed to add font: {:?}", e))?;
    
    current_layer.use_text("EU AI ACT - ANNEX IV TECHNICAL DOCUMENTATION", 24.0, Mm(20.0), Mm(270.0), &font);
    
    // Add sub-header: "Generated by Veridion Sovereign Nexus"
    let font_regular = doc.add_builtin_font(BuiltinFont::Helvetica)
        .map_err(|e| format!("Failed to add font: {:?}", e))?;
    
    current_layer.use_text("Generated by Veridion Sovereign Nexus", 12.0, Mm(20.0), Mm(250.0), &font_regular);
    
    // Add table header
    let mut y_position = 230.0;
    current_layer.use_text("Timestamp | Action | Seal ID", 10.0, Mm(20.0), Mm(y_position), &font_regular);
    y_position -= 15.0;
    
    // Add a separator line
    current_layer.use_text("────────────────────────────────────────────────────────────", 10.0, Mm(20.0), Mm(y_position), &font_regular);
    y_position -= 15.0;
    
    // Loop through the records and add them to the PDF
    for record in records {
        // Format the line: [Timestamp] | [Action] | [Seal ID]
        let line = format!("{} | {} | {}", record.timestamp, record.action_summary, record.seal_id);
        
        // Check if we need a new page (simple check - if y_position is too low)
        if y_position < 30.0 {
            // For now, just continue on the same page (in a real implementation, we'd add a new page)
            y_position = 230.0;
        }
        
        current_layer.use_text(&line, 9.0, Mm(20.0), Mm(y_position), &font_regular);
        y_position -= 12.0;
    }
    
    // Save the PDF to the output path
    doc.save(&mut BufWriter::new(File::create(output_path)
        .map_err(|e| format!("Failed to create file: {}", e))?))
        .map_err(|e| format!("Failed to save PDF: {:?}", e))?;
    
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_pdf_generation() {
        // Create a vector of 3 dummy ComplianceRecord items
        let records = vec![
            ComplianceRecord {
                timestamp: "2024-01-15 10:30:00".to_string(),
                action_summary: "Trade Executed".to_string(),
                seal_id: "QES_SEAL_abc123".to_string(),
                status: "COMPLETED".to_string(),
            },
            ComplianceRecord {
                timestamp: "2024-01-15 11:45:00".to_string(),
                action_summary: "Data Shredded".to_string(),
                seal_id: "QES_SEAL_def456".to_string(),
                status: "COMPLETED".to_string(),
            },
            ComplianceRecord {
                timestamp: "2024-01-15 12:00:00".to_string(),
                action_summary: "Compliance Check".to_string(),
                seal_id: "QES_SEAL_ghi789".to_string(),
                status: "VERIFIED".to_string(),
            },
        ];
        
        // Call generate_report
        let result = generate_report(&records, "test_report.pdf");
        assert!(result.is_ok(), "PDF generation should succeed");
        
        // Assert that the file test_report.pdf exists
        assert!(std::path::Path::new("test_report.pdf").exists(), "PDF file should exist");
        
        // Clean up: remove the test file
        let _ = std::fs::remove_file("test_report.pdf");
    }
}

